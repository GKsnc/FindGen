# FindGen

读作FindGen，写作寻根。目的是对流通商品进行溯源。  
还有一个含义，寻找下一代（Find Generation），希望这个项目能抛砖引玉，做出更好的。  
第一次做这种大型项目，有很多不成熟的地方，虽然没做到尽善尽美，但最核心的部分还是做出来了。  
虽然区块链的原理都摆在那，但去理解和如何将我要解决的问题与区块链联系起来，实现溯源等问题，是难点，也就是我们要解决的。  
所以完成这个项目，我的重点在设计，而不是在编写。  

## 概述

FindGen（以下简称FG）基于区块链体系来完成一个对商品进行溯源的系统。  
此系统由区块链+GFW组成。  
区块链涉及存储，加密，网络三个方面，很大程度参考[比特币开发者文档](https://bitcoin.org/zh_CN/developer-documentation)。  
GFW是我所设计的一个模型，目的是解决溯源问题，之后会具体讲解。  

## 系统开发

程序大体框架，系统层，接口层，用户层。
虽然看源码并没有表现出来，因为这是一个半成品。但在编写时，是有这个意识的。  
我们编写流程，先完成系统层所需要的一些模块，此处可以快速开发，只需简单的测试即可，然后在接口层，进行整合，根据我们要解决的问题，搭建模型。用户层，完成GUI（图形用户界面）。  
在一开始太好高骛远，直接将整个系统分配下去了，一开始的时候虽然有个大概计划，但没有很清楚的表示出来，导致前期开发很混乱，后期开始有条理进行开发了。  
不过，整个系统只有系统层与接口层，而且系统层缺少网络模块。接口层也没有很清晰的展示。  

## 数据结构

非必要阅读，下面这些留待参考：  
完全照搬比特币？这个模型运行在Records里。那么URC与GFW有区别吗？好像没有，我使用GFW不就是为了解决那些东西吗？  
所以就是gfw，urc没有存在的必要。那么如何来解决查询与验证呢？查询就根据商品ID就行，验证利用签名与公钥就行。  
而urc只是gfw中的一个数据结构，存储商品流通记录。
那个记录编号（recid）字段，设置为，前一记录的。但怎么取呢，取hash吗？但每次查找不就都要hash吗；  
那就先暂时取消；留作以后使用，当前暂时都设为0.  

>记录（Records）：  
> "version"：标识记录版本  
> "sign"：签名（由交易方签名）  
> "pub_key"：交易方的公钥  
> "crec"：  
>>"goods_id"：商品ID（商品的唯一标识）
>>"seq"：流通索引  
>>"circulate_flag"：流通标识（生产，购买。。。）  
>>"time"：时间戳  
>>"recid"：记录标识符（hash）  
>>"adress":被交易方的地址(base58)  

记录的数据结构，所有的流通记录均使用此结构。  
记录头由交易方填写，流通记录根据被交易方所需填写，商品（商品ID），地址（adress）.  
进行交易时,流通记录是与该商品的上一记录,想关联.  
商品ID(goods_id)延用,流通索引在上一条基础上加1,流通标识按具体进行填写(如生产,分销,购买等),recid延用上一条(单独看一条流通记录的意义并不大,所以一次流通有一个标识就可以);地址,被交易方的地址(比特币的p2pkh机制).

## 区块链

区块链是整个系统的核心也是基础。  
区块链是个体系，虽然表现起来是条链。  

### 存储

FG采用redis数据库与python的第三方库redis。  
redis是一个轻量级的数据库，一个实例占用不到1M。  
存储在数据库是json字符。存储类型和在系统中的类型，一开始没有计划好，导致前期类型非常混乱，字节型，字符型，json型，python数据类型，最后统一使用字符型+json格式的字符和python数据类型。  
目前系统层基本是字符型，接口层json格式的python数据类型。  
下一阶段统一数据类型的处理，目前看来，整个系统对数据类型的处理没有很清晰。  

### 加密

FG加密部分有：公私钥+地址，签名，hash。  
hash使用的是python内置库hashlib中sha256。  
用到hash的地方有Merkel树，区块hash，交易hash，地址。  
公私钥使用的是python第三方库fastecdsa的curve.P256。  
地址采用，base58编码公钥的hash，base58_encode(版本+hash(pub_key)+校验和)。  
签名，使用的是python第三方库fastecdsa的ecdsa（椭圆曲线数字签名算法）。  
hash与签名需要注意需要hash和签名的数据和排序后再进行。  
下一阶段，地址可以支持压缩存储（利用椭圆曲线的性质）。  
注：仓库里虽然有AES，暂未实装，是之后会使用到的模块。  

### 网络

P2P网络，待构建。  

## GFW

URC：未完成的记录；类似比特币中的utxo；为了解决查询避免遍历整个区块链和方便验证，所提出的模型。类似于缓存。  

GFW模型是为了利用区块链解决一个具体的问题所提出的，就比如区块链的核心是交易，为了利用区块链解决交易问题，就有了UTXO模型。  
这个系统为了解决溯源防伪就提出了GFW模型。  
底层是区块链，GFW调用区块链所提供的功能，来解决商品流通溯源问题。  

商品ID生成：  
系统中商品的唯一标识，利用雪花算法与ENA码来生成。  
编码空间有浪费，有优化的空间。

## 提出问题

为了更好的理解整个系统的运作，通过提出问题，来进行回答。

1. 如何生成区块？（如何发布区块？）  
这里的生成区块，不仅仅是生成一个区块的结构。而是如何在”区块链“上生成一个区块？  

2. 如何进行溯源？  

> 待整理，此处是草稿
记录生成，生产记录，流通记录，
由交易方发起，发向地址  
分为，生产记录，交易方发向被交易方的记录（交易记录）  
pub_key,sign为交易方的。
生产记录：  
recid由全部字段填写完后，填写  
goods_id只能由生产者生成（一个),16进制字符串  
seq置为0，circulate_flag置为0x000f  
time为生产的当前时间戳，adress为生产者的地址  
交易记录：  
recid为所用商品id（goods_id）生产记录的recid  
goods_id为交易的商品  
seq在前一条的基础上加1  
circulate_flag 根据流通规则填写，16进制字符  
time为交易当前的时间戳  
adress发向被交易方  
验证：  
生产记录，验证通过circulate_flag,goods_id,adress,pub_key,sign来验证
是否是生产记录,生产者是否合法,生产记录是否合法(可优化)  
交易记录,如果是中间流通,验证adress是否符合流通规则  
交易方,是否符合流通规则  
流通规则:  
可由厂商自行制定,但全局规则,不能违背  
TODO 全局规则见GFW模型的讨论(详见GFW README)  

商品ID,是单独生成还是整合到Records里呢?  
单独生成吧,由单独的模块来控制(好管理生成,防止生产者滥用)  
如何管理商品ID,这个问题之后想想  

生产，生成商品ID（此处有BNA码，为将来可能需要的验证做准备），验证改商品ID是否冲突（不需要，设计的时候，就已经考虑了这种情况）
交易，交易商品，通过查找商品ID，找到交易标识，根据之前的交易填写字段，发向被交易方
验证，所有的验证都在发布区块和接受区块时进行。
验证说明：
        # TODO(ZHOU) 此商品ID之前所有的流通记录,
        # 先搜索，判断；这件事，可以在初始化是，完成，或者空闲时间，完成，；
        # 这个功能实现在blockchain模块中
        # 验证ID冲突,验证
        # 填写流通记录（生成一条流通记录，内含验证）TODO 验证之前的记录待定
        # 创建只做创建功能，验证由模块统一验证，因为这个记录，别人收到肯定会进行验证，或者发布的时候进行验证
        # 创建需要什么规则吗？
        # 流通记录的字段怎么填写？
        # 商品ID，流通标识，地址，私钥，公钥，由交易方填写，剩下的交由系统
        # 剩下的就只有序号，这个字段该怎么填写？
        # 需要验证 环节吗？还是直接调用数据库，来填写？
        # 还有交易标识（recid）这个字段，也就是肯定需要之前的记录
        # 那就调用之前的
        # 由之前交易标识,将字段延续下来
        # 如何验证
        # TODO(ZHOU) 注意某些地方需要校验
        # 参与者加入，gfw模型的运作，参与者的行为要满足gfw模型的规则与与区块链的规则
        # 只要商品在流通时留下记录（可信），那么就可查
        # 区块链是为了实现可信，记录，
        # gfw是为了规范记录；（怎么感觉有点类似以太坊的智能合约）

        # 也就是说这么多模块，几乎都是为了区块链而服务的

3. 如何防伪？  
这个问题涉及到很多密码学相关，可以参考比特币。  

## 其他

我认为比特币是对过去20年（待考，密码学，p2p，交易机制）计算机领域发展的总结。
单看单个技术，确实很好理解，但如何巧妙的结合起来。这正是比特币解决的问题，也是我现在再解决的问题。
比特币不是匿名的，相反，严格来讲，比特币是完全公开而且可追踪的。与其说比特币是匿名，不如说是非实名的。换句话说，某论坛，你不用真名注册，不填写个人信息，你的唯一代号是你的id，这叫非实名；你发帖选择匿名用户，这才叫匿名。

TODO ： 用户认证问题，【地址模块】
    按照设计的模型，谁都能发布吗，需要什么，如何公开，
    登录，注册（网络中通信？）
    看看比特币是如何解决用户问题的
    比特币是因为支付付费有节点，就知道有这个账户了，区块链本身就包括用户了
    并不需要专门用什么来维护
    不过公私钥的生成，还是需要有点讲究的
    看看比特币是如何管理公私钥的；公钥，私钥，地址，钱包（身份认证）
    比特币是如何管理公私钥
    <https://www.jianshu.com/p/af6328cc693e>
    （因为私钥可取的空间非常大，我们所说的比特币私钥的是密码学上面安全的，并不是说不可能出现重复的私钥，而是说不可能通过遍历的方式找到某一个特定的私钥，或者通过其它的方式找，而不通过私钥就能花费地址上面的比特币，私钥的安全性是由数学上保证的。
    目前是通过第三方认证或者由商品编码来获取原信息，不过由于匿名的原因，无法追踪到个人（那有什么用呢），可以用私钥分发的方式（第三方，或者程序实现私钥分发）
    要不中间流通全都用第三方认证，毕竟商品流通中间环节都是一些代理商之类的，如果是个人，也可以去找第三方认证之后才可以购买
    但这样损失了很多，标识地址就可以了，不用私钥


奖励，惩罚机制（未来更新）


### 未来更新  

* 为了方便安装，将程序打包docker（两种安装方式，docker待了解）并使用web访问的模式（B/S）
* 多线程处理
* 共识算法的更新
* P2P网络模块
* ENA13商品ID生成，优化与添加验证模块
* 类结构调整；（Records类与Participants类；blockchain类与redis类等，方法权限管理）
* 验证模块统一；上链，发布区块，接收区块，发布记录，接受记录等
