# FindGen

读作FindGen，写作寻根，意味找寻根源。系统的目的就是对流通商品进行溯源。  
这个系统要完整的做出来对我们这个小组很困难，所以它还有一个意义，寻找下一代（Find Generation），意作下一个版本系统会更好。  
完成这个项目，我的重点在设计，而不是在编写。  

## 概述

FindGen（以下简称FG）基于区块链体系来完成一个去中心化溯源系统。  
涉及存储，加密，网络三个方面，同样也是三个难点。  
如何巧妙联系起来，实现去中心化，防伪等问题，就是区块链所解决的。  
此系统主要解决核心问题，其他模块在具体应用场景进行编写。  

## 区块链

区块链是整个系统的核心也是基础。  
接下来分三个方面来阐述。  

### 加密

使用比特币系统的加密方式。（待补充）

### 存储

比特币系统的存储方式。（待补充）

### 网络

比特币系统的网络模式。（待补充）

## GFW

GFW模型是为了利用区块链解决一个具体的问题所提出的，就比如区块链的核心是交易，为了利用区块链解决交易问题，就有了UTXO模型。  
这个系统为了解决溯源防伪就提出了GFW模型。  
底层是区块链，GFW调用区块链所提供的功能，来解决商品流通溯源问题。  

商品ID生成：  
系统中商品的唯一标识，利用雪花算法与ENA码来生成。  
编码空间有浪费，有优化的空间。

### 数据结构

URC：未完成的记录；类似比特币中的utxo；为了解决查询避免遍历整个区块链和方便验证，所提出的模型。类似于缓存。  

非必要阅读，下面这些留待参考：  
完全照搬比特币？这个模型运行在Records里。那么URC与GFW有区别吗？好像没有，我使用GFW不就是为了解决那些东西吗？  
所以就是gfw，urc没有存在的必要。那么如何来解决查询与验证呢？查询就根据商品ID就行，验证利用签名与公钥就行。  
而urc只是gfw中的一个数据结构，存储商品流通记录。
那个记录编号（recid）字段，设置为，前一记录的。但怎么取呢，取hash吗？但每次查找不就都要hash吗；  
那就先暂时取消；留作以后使用，当前暂时都设为0.  

>记录（Records）：  
> "version"：标识记录版本  
> "sign"：签名（由交易方签名）  
> "pub_key"：交易方的公钥  
> "crec"：  
>>"goods_id"：商品ID（商品的唯一标识）
>>"seq"：流通索引  
>>"circulate_flag"：流通标识（生产，购买。。。）  
>>"time"：时间戳  
>>"recid"：记录标识符（hash）  
>>"adress":被交易方的地址(base58)  

记录的数据结构，所有的流通记录均使用此结构。  
记录头由交易方填写，流通记录根据被交易方所需填写，商品（商品ID），地址（adress）.  
进行交易时,流通记录是与该商品的上一记录,想关联.  
商品ID(goods_id)延用,流通索引在上一条基础上加1,流通标识按具体进行填写(如生产,分销,购买等),recid延用上一条(单独看一条流通记录的意义并不大,所以一次流通有一个标识就可以);地址,被交易方的地址(比特币的p2pkh机制).

## 提出问题

为了更好的理解整个系统的运作，通过提出问题，来进行回答。

1. 如何生成区块？（如何发布区块？）  
这里的生成区块，不仅仅是生成一个区块的结构。而是如何在”区块链“上生成一个区块？  

2. 如何进行溯源？  

> 待整理，此处是草稿
记录生成，生产记录，流通记录，
由交易方发起，发向地址  
分为，生产记录，交易方发向被交易方的记录（交易记录）  
pub_key,sign为交易方的。
生产记录：  
recid由全部字段填写完后，填写  
goods_id只能由生产者生成（一个),16进制字符串  
seq置为0，circulate_flag置为0x000f  
time为生产的当前时间戳，adress为生产者的地址  
交易记录：  
recid为所用商品id（goods_id）生产记录的recid  
goods_id为交易的商品  
seq在前一条的基础上加1  
circulate_flag 根据流通规则填写，16进制字符  
time为交易当前的时间戳  
adress发向被交易方  
验证：  
生产记录，验证通过circulate_flag,goods_id,adress,pub_key,sign来验证
是否是生产记录,生产者是否合法,生产记录是否合法(可优化)  
交易记录,如果是中间流通,验证adress是否符合流通规则  
交易方,是否符合流通规则  
流通规则:  
可由厂商自行制定,但全局规则,不能违背  
TODO 全局规则见GFW模型的讨论(详见GFW README)  

商品ID,是单独生成还是整合到Records里呢?  
单独生成吧,由单独的模块来控制(好管理生成,防止生产者滥用)  
如何管理商品ID,这个问题之后想想  

生产，生成商品ID（此处有BNA码，为将来可能需要的验证做准备），验证改商品ID是否冲突（不需要，设计的时候，就已经考虑了这种情况）
交易，交易商品，通过查找商品ID，找到交易标识，根据之前的交易填写字段，发向被交易方
验证，所有的验证都在发布区块和接受区块时进行。
验证说明：
        # TODO(ZHOU) 此商品ID之前所有的流通记录,
        # 先搜索，判断；这件事，可以在初始化是，完成，或者空闲时间，完成，；
        # 这个功能实现在blockchain模块中
        # 验证ID冲突,验证
        # 填写流通记录（生成一条流通记录，内含验证）TODO 验证之前的记录待定
        # 创建只做创建功能，验证由模块统一验证，因为这个记录，别人收到肯定会进行验证，或者发布的时候进行验证
        # 创建需要什么规则吗？
        # 流通记录的字段怎么填写？
        # 商品ID，流通标识，地址，私钥，公钥，由交易方填写，剩下的交由系统
        # 剩下的就只有序号，这个字段该怎么填写？
        # 需要验证 环节吗？还是直接调用数据库，来填写？
        # 还有交易标识（recid）这个字段，也就是肯定需要之前的记录
        # 那就调用之前的
        # 由之前交易标识,将字段延续下来
        # 如何验证
        # TODO(ZHOU) 注意某些地方需要校验
        # 参与者加入，gfw模型的运作，参与者的行为要满足gfw模型的规则与与区块链的规则
        # 只要商品在流通时留下记录（可信），那么就可查
        # 区块链是为了实现可信，记录，
        # gfw是为了规范记录；（怎么感觉有点类似以太坊的智能合约）

        # 也就是说这么多模块，几乎都是为了区块链而服务的

3. 如何防伪？  
这个问题涉及到很多密码学相关，可以参考比特币。  

## 其他

我认为比特币是对过去20年（待考，密码学，p2p，交易机制）计算机领域发展的总结。
单看单个技术，确实很好理解，但如何巧妙的结合起来。这正是比特币解决的问题，也是我现在再解决的问题。
比特币不是匿名的，相反，严格来讲，比特币是完全公开而且可追踪的。与其说比特币是匿名，不如说是非实名的。换句话说，某论坛，你不用真名注册，不填写个人信息，你的唯一代号是你的id，这叫非实名；你发帖选择匿名用户，这才叫匿名。

TODO ： 用户认证问题，【地址模块】
    按照设计的模型，谁都能发布吗，需要什么，如何公开，
    登录，注册（网络中通信？）
    看看比特币是如何解决用户问题的
    比特币是因为支付付费有节点，就知道有这个账户了，区块链本身就包括用户了
    并不需要专门用什么来维护
    不过公私钥的生成，还是需要有点讲究的
    看看比特币是如何管理公私钥的；公钥，私钥，地址，钱包（身份认证）
    比特币是如何管理公私钥
    <https://www.jianshu.com/p/af6328cc693e>
    （因为私钥可取的空间非常大，我们所说的比特币私钥的是密码学上面安全的，并不是说不可能出现重复的私钥，而是说不可能通过遍历的方式找到某一个特定的私钥，或者通过其它的方式找，而不通过私钥就能花费地址上面的比特币，私钥的安全性是由数学上保证的。
    目前是通过第三方认证或者由商品编码来获取原信息，不过由于匿名的原因，无法追踪到个人（那有什么用呢），可以用私钥分发的方式（第三方，或者程序实现私钥分发）
    要不中间流通全都用第三方认证，毕竟商品流通中间环节都是一些代理商之类的，如果是个人，也可以去找第三方认证之后才可以购买
    但这样损失了很多，标识地址就可以了，不用私钥

统一使用hash函数，sha256（先排序，再hash）

奖励，惩罚机制（未来更新）

### 未来更新  

* 为了方便安装，将程序打包docker（两种安装方式，docker待了解）并使用web访问的模式（B/S）
* 多线程处理
* 共识算法的更新
* P2P网络模块
* ENA13商品ID生成，优化与添加验证模块
* 类结构调整；（Records类与Participants类；blockchain类与redis类等，方法权限管理）
* 验证模块；上链，发布区块，接收区块，发布记录，接受记录等
